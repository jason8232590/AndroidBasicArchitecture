package com.example.myapplication.algorithm.Search

class HashTableSearch {
    //map.for each去遍历
//    1.基本思想
//    散列表是基于数组的，可以快速查找元素,数据需要遍历数组，散列表通过key的hash值来计算出index.
//    所以相同的key, hashcode一致，存储位置一致。

//      2.时间复杂度
//      最好情况O(1)
//      最坏情况，hash冲突严重，就相当于要遍历链表了，时间复杂度O(n)

//       3.解决散列冲突
//       3.1开放寻址法(包含线性探测，二次探测,双重散列)
//       缺点： 删除数据麻烦，空闲空间越来越小(装载因子不能太大)，极端情况可能需要探测整个散列表，最坏情况O(n)
//       优点：散列表中的数据都存储在数组中，查询速度块，序列化简单
//       使用场景： 数据量较小，装载因子小的时候， ThreadLocal
//
//       3.2链表
//       每个buket都会有一个链表，所有hash值相同的元素我们都放在相同槽中
//       缺点：里面包含指针，不方便序列化(数据分散，序列化是要转成一个连续的字节流)
//            数据分散，对CPU缓存不是很友好
//            需要额外空间存储指针
//
//       优点： 内存利用率高，需要的时候再创建，不需要像开放寻址法那样一开始就声明号
//             装载因子再大也没事，最多就是链表的长度变大
//             如果存储是大对象，那对象的大小远远大于一个指针大小，那么内存消耗可以忽略


//          4.动态扩容的效率提高
//             不一次性扩容，而是新数据插入新散列表然后带一个老的数据
//             查找就先查找新散列表再找老的散列表


//            5.工业设计标准
//               1.hash函数不能太复杂，否则影响计算性能
//                2.定义装载因子，并且设计动态扩容策略
//               3.选择合适的散列冲突解决办法

//           6. 总结
//    基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表
}