package com.example.myapplication.algorithm.Search;

public class JumpTable {
//    数据存储在数组里用二分法，那如果存在链表上呢？用跳表！！！
//<1>基本思想
//            就是每隔几个结点建立一个索引
//
//
//
//<2>时间复杂度
//
//    假设一个链表有n个结点，如果每两个抽一个结点，那一级索引有n/2个结点，第二级有n/4个结点，第k级有n/2^*(k-1)个结点
//    假设最顶层，也就是第k层只有两个结点，那么n/2^*(k-1) = 2， k= logn -1,包括最原始那一层，总共就有logn 层，假设每层都要遍历m个结点，那么时间复杂度就是O(mlogn)
//
//    m在这里就是3(每两个节点一个索引的抽法)
//
//    所以时间复杂度是logn
//<3>空间复杂度
//    要保存各级索引，所以空间复杂度是O(n),典型的以空间换时间的思想，而且
//    实际开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。
//
//<4>插入删除复杂度
//    插入删除本身复杂度是O(1)，但是查找是O(logn)
//
//<5>缺点
//    如果插入节点太多，那么两个索引之间就有太多结点了，可能会退化成链表，所以我们用一个随机数来支持跳表的索引动态更新。
//    我们通过一个随机函数，来决定这个结点插入到哪几级索引中，比如随机函数生成了值K,那我们就把这个结点添加到第一级  到  第K级这K级索引中。
//
//
//<6>使用场景
//    适合插入，删除，查找，但是重要的，可以按照区间查找数据，这个比红黑树的效率高，
//    对于跳表我们花费O(logn)来定位区间的起点，然后再往后面按顺序查找即可
}
