package com.example.myapplication.algorithm.sortMethod
//归并排序
class MergeSort {
//    /**
//     * 采用分治思想
//     * 把数组分成两半(子数组继续拆，直到最后一个元素是1个！！！)， 然后分别进行排序最后进行合并
//     *merge_sort(p..r) 就可以分成 Merge_sort(p...q) 和Merge_Sort(q...r)
//     *然后再把两个有序子数组合并在一起(需要比大小)
//     * 合并两个子数组的方法：
//     * 1.创建一个临时数组temp,大小跟A[p..r]一样大
//     * 2.取出两个子数组的第一个数B[i]  c[j] 比大小，
//     * 3.如果B[i] <= C[j] 那么就把B[i] 放进数组，然后i加1
//     * 4.否则 就把C[j]放入数组，j+1
//     * */


///**
// *  伪代码如下

// *  归并排序算法, A是数组，n表示数组大小
//    merge_sort(A, n) {
//        merge_sort_c(A, 0, n-1)
//    }*/
//
///**     递归调用函数 (p是初始位置)
//         merge_sort_c(A, p, r) {
//        // 递归终止条件 ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！ 也就是数组最后只剩下一个元素
//        if p >= r  then return
//
//        // 取p到r之间的中间位置q
//        q = (p+r) / 2
//        // 分治递归
//        merge_sort_c(A, p, q)
//        merge_sort_c(A, q+1, r)
//
//        // 将A[p...q]和A[q+1...r]合并为A[p...r]
//        merge(A[p...r], A[p...q], A[q+1...r])
//    }*/

    /***
     * 1.时间复杂度  用递归方法来分析
     * (1)假设将n个元素进行归并排序需要的时间是T(n),那么可以将分拆成2*T（n/2）+ n
     *  T(n/2)是一个子数组的排序,  O(n)是最后合并两个子数组的复杂度
     *  T(1) = 1
     *  T(n) = 2 * T(n/2)+n
     *  T(n) = 2 * (2*T(n/4)+n/2) +n = 4*T(n/4)+ 2n
     *  T(n) = 4*(2*T(n/8)+ 4/n )+ 2n = 8*T(n/8) +3n
     *
     *  假如总共要拆分k次到就剩1个元素 T(1) = 1
     *
     *  T(n) = 2^k*T(n/2^k) + k*n
     *  因为拆到只有一个元素，所以 T(n/2^k) = T(1)
     *  k = logn 省略了底数2，将K代入原来的公式
     *  得到 T(n) = Cn + nlogn
     *
     *  所以归并排序的复杂度是 O(nlogn)
     *
     * 2.是稳定排序    相同元素位置不会发生改变
     * 3.不是原地排序  因为最后合并两个子数组的时候创建了临时数组，空间复杂度是O(n)
     *
     *
     * */
}