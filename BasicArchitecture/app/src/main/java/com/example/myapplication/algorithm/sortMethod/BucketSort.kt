package com.example.myapplication.algorithm.sortMethod

class BucketSort {
//    1)核心思想：把排序的数据分到有序的桶里，每个桶在单独进行排序就可以，然后在把每个桶的数据取出，然后就排序拍好了
//    假如n个数据，M个桶，每个桶都用快排(时间复杂度是klogk  k为桶中元素 k = n/m),那总的时间复杂度就是O(m* n/m log(n/m)),也就是 O(n*log(n/m))
//
//    2)时间复杂度
//    最好的情况是当m 接近n,也就是每个桶一个元素的时候，时间复杂度是O(n)
//    最坏的情况是所有元素都在一个桶O(nlogn)
//
//    3)缺点
//    缺点： 数据分布不平均，可能一个桶里集中大部分数据
//
//    4)使用场景
//    桶排序比较适合用在外部排序中
//    我们有10GB的订单数，希望按订单金额(假设金额都是正整数)进行排序，但是我们的内存有限，只有几百MB,没办法一次性把10GB的数据都加载到内存中，这个时候该怎么办？
//
//    1.先扫描文件看订单金额所处的数据范围，假如最小1元，最大是10万
//    2.我们将所有订单根据金额划分到100个桶里，第一个桶存1元-1000元，第二个桶存1001-2000元之内，以此类推
//    3.每个桶对应一个文件，并且按照金额范围的大小顺序编号命名(00,01,02..99)
//
//    理想情况，订单均匀分布在100个桶，每个小文件大约存储了100MB,然后把每个桶放进内存进行快排，然后在挨个读出来
//
//    不理想情况，不均匀分布，那就继续分桶，直到可以均匀分布
}